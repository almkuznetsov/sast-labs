# Знакомство с SAST
## Зачем это нужно?
В коде программ могут содержаться различные ошибки, некоторые из которых могут быть уязвимостями.

Уязвимости могут позволить реализовать атаки различной сложности. Как правило, уязвимостям в популярных проектах присваивается идентификатор - специальный номер, по которому можно удобно отслеживать информацию об уязвимости и узнавать, закрыта она в конкретной версии программы, или нет.
Примерами таких идентификаторов служат [БДУ](https://bdu.fstec.ru/) и [CVE](https://www.cve.org/). Несколько примеров нашумевших уязвимостей (настолько нашумевших, что им даже дали отдельные "имена") - [Heartbleed (CVE-2014-0160)](https://www.cve.org/CVERecord?id=CVE-2014-0160), [Boothole (CVE-2020-10713)](https://www.cve.org/CVERecord?id=CVE-2020-10713), [log4shell (CVE-2021-44228)](https://www.cve.org/CVERecord?id=CVE-2021-44228) [RegreSSHion (CVE-2024-6387)](https://www.cve.org/CVERecord?id=CVE-2024-6387).

Ошибки, которые в последствии оказываются уязвимостями, можно обнаружить, используя подходы безопасной разработки ПО, например - статический анализ (SAST).
Статический анализ — анализ кода программы без её запуска. Такой анализ может позволить выявить содержащиеся в коде ошибки и, возможно, предотвратить появление уязвимостей. Для статического анализа применяются специальные программы - статические анализаторы.

В ходе этой работы мы воспользуемся двумя различными статическими анализаторами, чтобы рассмотреть уязвимости CVE-2013-6462 и CVE-2014-8130. Мы найдем их в исходном коде программ, подготовим исправления и убедимся, что уязвимости закрыты. На этих примерах мы познакомимся с реальным циклом анализа программ и подготоки патчей безопасности.

## Начальные условия
Дальнейшие задания подразумевают наличие у выполняющего следующих знаний:
 - Знакомство с git (на уровне `git add` и `git commit`). Много полезных ссылок и информации по работе с git - https://www.altlinux.org/Git
 - Базовое знакомство с C/C++
 - Базовые навыки работы в командной строке
 - Если работа будет выполняться в контейнере - знакомство с [Podman](https://www.altlinux.org/Podman)/[Docker](https://www.altlinux.org/Docker).

Для выполнения всех заданий нам потребуется на выбор:
1. Ноутбук/виртуальная машина с установленной ОС "Альт" (https://getalt.org/ru/), либо
2. Podman/Docker (`podman run --network=host -ti alt:p11`)

Мы будем использовать второй вариант, поэтому:
1. Далее не будет разделения на команды пользователя и суперпользователя, в случае выполнения на локальной/виртуальной машине для выполнения, например, команд `apt-get install` потребуются права суперпользователя
2. Некоторые версии устанавливаемых на локальной/виртуальной машине программ могут отличаться. Например, для ОС на базе p10 необходимо использовать `clang17.0-analyzer` и `llvm17.0` во второй части задания.

## Часть 1. Cppcheck и CVE-2013-6462
[Cppcheck](https://cppcheck.sourceforge.io/) - статический анализатор с открытым исходным кодом.
Уязвимость CVE-2013-6462 была обнаружена с помощью cppcheck в проекте [libXfont](https://gitlab.freedesktop.org/xorg/lib/libxfont). LibXfont предоставляет ядро legacy системы шрифтов для оконной системы X11.
Давайте воспроизведем процесс обнаружения и исправления описанной уязвимости.

В ходе выполнения заданий 1 части у нас должны получиться следующие артефакты работы:
- скриншоты выполнения пунктов задания
- файл cppcheck.out с результатами первичного статического анализа
- файл cppcheck2.out с результатами статического анализа после исправления уязвимости
- файл, содержащий подготовленный с помощью `git format-patch` патч, испраляющий уязвимость

### Настройка окружения
Поскольку cppcheck работает с текстами программ, а не собирает их, нам потребуются только сам cppcheck и git
```shell
apt-get update
apt-get install git cppcheck
```
Склонируем себе репозиторий с этим заданием, дальнейшие действия будем выполнять внутри него
```shell
git clone https://gitlab.basealt.space/kuznetsovam/sast-labs
cd sast-labs
```
Склонируем себе репозиторий с проектом libXfont и перейдем в его директорию
```shell
git clone https://gitlab.freedesktop.org/xorg/lib/libxfont
cd libxfont
```

### Статический анализ
В новой версии libxfont рассматриваемая нами уязвимость исправлена. Чтобы проанализировать код, где она еще не была исправлена, откатимся к версии 1.4.6
```shell
git checkout libXfont-1.4.6
```
Запустим статический анализ со следующими опциями:
```shell
-j4 - запуск анализа в 4 потока для ускорения анализа
--enable=all - по умолчанию cppcheck использует небольшое количество проверок, которые с большой вероятностью не дадут ложных срабатываний, но мы включим все имеющиеся проверки
```
Также после команды анализа добавим `2> cppcheck.out`, чтобы перенаправить вывод информации об обнаруженных ошибках в файл `cppcheck.out`
В результате получится следующая команда для запуска анализа (не забываем о символе точки `.` - он указывает, где находятся файлы, которые мы анализируем):
```shell
cppcheck -j4 --enable=all . 2> cppcheck.out
```

### Разбор срабатываний
Откроем удобным текстовым редактором файл cppcheck.out. Как видим, в нем содержится большое количество сработок. Сегодня нас будет интересовать конкретная сработка - найдем ее по ключевому слову "sscanf" и строке `src/bitmap/bdfread.c:341`:
```
src/bitmap/bdfread.c:341:6: warning: sscanf() without field width limits can crash with huge input data. [invalidscanf]
```
Разберемся в проблеме, вызвавшей сработку - если не ограничивать количество символов, которые можно прочитать с помощью функции sscanf(), то атакующий может подать большой объем данных, который приведет к "падению" библиотеки, или даже запуску произвольного кода.

### Исправление ошибки
Для исправления данной проблемы необходимо ограничить максимальное количество символов, которые можно прочитать. Для этого можно, например заменить `"STARTCHAR %s` в указанной строке на `"STARTCHAR %80s`, ограничив ввод 80 символами.

Самостоятельно проведите указанное или подобное ему исправление, внесите его в систему контроля версий с помощью команд `git add` и `git commit` (если мы внутри контейнера, для этого может потребоваться настроить git), а затем повторно запустите статический анализ. Убедитесь, что рассматриваемое срабатывание больше не появляется.

### Подготовка патча
После того, как нам удалось локально исправить проблему, необходимо подготовить патч, который можно выслать разработчикам для обсуждения. Подготовить патч из последнего коммита можно командой
```
git format-patch -1 HEAD
```

### Итог 1 части
В ходе 1 части мы познакомились со статическим анализатором cppcheck, который работает с исходными текстами программ, проанализировали уязвимую к CVE-2013-6462 версию библиотеки libXfont, обнаружили данную уязвимость посредством статического анализа, исправили ее и убедились в отсутствии повторного срабатывания статического анализатора.

Дополнительно:
- Сравните ваше исправление с коммитом, который действительно использовался для исправления этой уязвимости (информацию об уязвимости удобно смотреть по ее идентификатору на https://CVE.org)
- Попробуйте изменить формат вывода ошибок cppcheck, например, с помощью ключа `--template='{id} {file}:{line} {message}'`, оцените какой формат вывода ошибок представляется вам наиболее удобным для восприятия и анализа

## Часть 2. Clang static analyzer и CVE-2014-8130
[Clang static analyzer](https://clang-analyzer.llvm.org/) - это статический анализатор на базе компилятора clang, который, в свою очередь, входит в проект LLVM.
Уязвимость CVE-2014-8130 была обнаружена в библиотеке для работы с TIFF-файлами [libtiff](https://gitlab.com/libtiff/libtiff).
Давайте попробуем обнаружить и исправить эту уязвимость, опираясь на статический анализ с помощью clang static analyzer.

В ходе выполнения заданий 2 части у нас должны получиться следующие артефакты работы:
- скриншоты выполнения пунктов задания
- файл, содержащий подготовленный с помощью `git format-patch` патч, испраляющий уязвимость

### Настройка окружения
Поскольку clang static analyzer построен на базе компилятора clang, он позволяет проводить более глубокий анализ программы путем участия в ее сборке. Следовательно, для такого анализа нам потребуется собрать библиотеку libtiff, а значит нам потребуется установить ее зависимости:
```shell
apt-get install make libSM-devel libXi-devel libXmu-devel libfreeglut-devel libjpeg-devel liblzma-devel libwebp-devel libzstd-devel zlib-devel libdeflate-devel
```
 Также установим LLVM и сам clang static analyzer
```shell
apt-get install clang18.1-analyzer gcc-c++ llvm18.1
```
Склонируем себе репозиторий с проектом libtiff и перейдем в его директорию
```
cd .. # возвращаемся в директорию sast-labs
git clone https://gitlab.com/libtiff/libtiff
cd libtiff
```

### Статический анализ
В новой версии libtiff рассматриваемая нами уязвимость исправлена. Чтобы проанализировать код, где она еще не была исправлена, откатимся к версии 4.0.3
```shell
git checkout v4.0.3
```
Чтобы провести статический анализ с использованием clang static analyzer, можно использовать утилиту scan-build, которая проведет сборку нашего проекта с необходимыми для статического анализа настройками компилятора. Поскольку наш проект собирается с помощью скрипта `configure` и утилиты `make`, то для сборки со статическим анализом используем следующие команды
```shell
scan-build ./configure
scan-build make -j4
```
Здесь ключ `-j4` запускает сборку в несколько потоков, что позволяет ускорить этот процесс.

### Разбор срабатываний
После завершения работы утилиты scan-build будет выведено сообщение вида
```shell
scan-build: Run 'scan-view /tmp/.private/[..]' to examine bug reports.
```
Запустив указанную команду мы сможем ознакомиться с результатами статического анализа в любом браузере по указанному в выводе команды адресу.

Нас будет интересовать первое срабатывание детектора `Division by zero` в файле `libtiff/tif_write.c:119`.
Как видим, `td->td_stripsperimage` может быть равным нулю, в результате чего может возникнуть деление на ноль.

Для этой уязвимости у нас есть proof of conecpt (PoC) файл - это файл, позволяющий продемонстрировать существование уязвимости. Давайте остановим работу утилиты scan-view (Ctrl+C) и попробуем воспроизвести эксплуатацию уязвимости, для этого подадим на вход собранной нами утилите tiffdither специально сформированный tiff файл, который приведет к рассматриваемому нами делению на ноль
```shell
./tools/tiffdither ../15_tiffdither.tiff out.tiff
```
Мы должны увидеть сообщение вида `floating point exception`, свидетельствующего о том, что выполнение программы было прервано указанным исключением.

### Исправление ошибки
Для исправления ошибки можно добавить проверку, равен ли `td->td_stripsperimage` нулю непосредственно перед проведением деления. Проверка может выглядеть следующим образом
```c
if (td->td_stripsperimage == 0) {
	return (-1);
}
```

Самостоятельно проведите указанное или подобное ему исправление, внесите его в систему контроля версий с помощью команд `git add` и `git commit`, а затем повторно запустите статический анализ (для этого потребуется сначала удалить результаты предыдущей сборки с помощью `make clean`). Убедитесь, что рассматриваемое срабатывание больше не появляется, а также что PoC-файл больше не вызывает описанное исключение.

### Подготовка патча
Аналогично первой части необходимо подготовить патч с помощью команды `git format-patch`

### Итог 2 части
В ходе 2 части мы познакомились с clang static analyzer, который позволяет проводить более глубокий анализ за счет участия в сборке программы. Проанализировали уязвимую к CVE-2014-8130 версию библиотеки libtiff, обнаружили данную уязвимость посредством статического анализа, проверили ее наличие с помощью PoC-файла, исправили ее и убедились в отсутствии повторного срабатывания статического анализатора.

Дополнительно:
- Сравните ваше исправление с коммитом, который действительно использовался для исправления этой уязвимости (информацию об уязвимости удобно смотреть по ее идентификатору на https://CVE.org).


## Changelog
- 06.08.2024 1.1
	- Исправлена неверная ссылка на срабатывание статического анализатора в части 2 (спасибо Шишкову Никите, Сарафанникову Даниилу, Селезневу Александру (СГУ))

- 11.07.2024 1.0
	- Добавлены задания по подготовке патчей
	- Расширена информация об уязвимостях
	- Добавлен список артефактов, получаемых в ходе выполнения заданий

- 10.07.2024 0.1
	- Подготовлены части 1 и 2
